(ns portkey.aws.kinesisvideo (:require [portkey.aws]))

(def endpoints 'nil)

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/fragment-number-string (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__15966__auto__] (clojure.core/<= 1 (clojure.core/count s__15966__auto__))) (clojure.core/fn [s__15967__auto__] (clojure.core/< (clojure.core/count s__15967__auto__) 128)) (clojure.core/fn [s__15968__auto__] (clojure.core/re-matches #"^[0-9]+$" s__15968__auto__))))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/stream-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__15966__auto__] (clojure.core/<= 1 (clojure.core/count s__15966__auto__))) (clojure.core/fn [s__15967__auto__] (clojure.core/< (clojure.core/count s__15967__auto__) 256)) (clojure.core/fn [s__15968__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_.-]+" s__15968__auto__))))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.get-media-input/streamarn (clojure.spec.alpha/and :portkey.aws.kinesisvideo/resourcearn))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/get-media-input (portkey.aws/json-keys :req-un [:portkey.aws.kinesisvideo/StartSelector] :opt-un [:portkey.aws.kinesisvideo/StreamName :portkey.aws.kinesisvideo.get-media-input/StreamARN] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.invalid-endpoint-exception/message (clojure.spec.alpha/and :portkey.aws.kinesisvideo/error-message))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/invalid-endpoint-exception (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo.invalid-endpoint-exception/Message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.not-authorized-exception/message (clojure.spec.alpha/and :portkey.aws.kinesisvideo/error-message))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/not-authorized-exception (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo.not-authorized-exception/Message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/payload (clojure.spec.alpha/and clojure.core/bytes? (clojure.spec.alpha/conformer portkey.aws/base64-encode portkey.aws/base64-decode)))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/content-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__15966__auto__] (clojure.core/<= 1 (clojure.core/count s__15966__auto__))) (clojure.core/fn [s__15967__auto__] (clojure.core/< (clojure.core/count s__15967__auto__) 128)) (clojure.core/fn [s__15968__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\.\-]+$" s__15968__auto__))))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.start-selector/after-fragment-number (clojure.spec.alpha/and :portkey.aws.kinesisvideo/fragment-number-string))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo.start-selector/start-timestamp (clojure.spec.alpha/and :portkey.aws.kinesisvideo/timestamp))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/start-selector (portkey.aws/json-keys :req-un [:portkey.aws.kinesisvideo/StartSelectorType] :opt-un [:portkey.aws.kinesisvideo.start-selector/AfterFragmentNumber :portkey.aws.kinesisvideo.start-selector/StartTimestamp :portkey.aws.kinesisvideo/ContinuationToken] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.resource-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.kinesisvideo/error-message))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/resource-not-found-exception (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo.resource-not-found-exception/Message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/start-selector-type (clojure.spec.alpha/conformer (clojure.core/let [m__15964__auto__ {"EARLIEST" "EARLIEST", "NOW" "NOW", "FRAGMENT_NUMBER" "FRAGMENT_NUMBER", "PRODUCER_TIMESTAMP" "PRODUCER_TIMESTAMP", :now "NOW", :producer-timestamp "PRODUCER_TIMESTAMP", :fragment-number "FRAGMENT_NUMBER", :earliest "EARLIEST", :continuation-token "CONTINUATION_TOKEN", "SERVER_TIMESTAMP" "SERVER_TIMESTAMP", "CONTINUATION_TOKEN" "CONTINUATION_TOKEN", :server-timestamp "SERVER_TIMESTAMP"}] (clojure.core/fn [s__15965__auto__] (m__15964__auto__ s__15965__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.put-media-input/streamarn (clojure.spec.alpha/and :portkey.aws.kinesisvideo/resourcearn))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo.put-media-input/producer-start-timestamp (clojure.spec.alpha/and :portkey.aws.kinesisvideo/timestamp))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/put-media-input (portkey.aws/json-keys :req-un [:portkey.aws.kinesisvideo/FragmentTimecodeType] :opt-un [:portkey.aws.kinesisvideo/StreamName :portkey.aws.kinesisvideo.put-media-input/StreamARN :portkey.aws.kinesisvideo.put-media-input/ProducerStartTimestamp :portkey.aws.kinesisvideo/Payload] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/put-media-output (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo/Payload] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.client-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.kinesisvideo/error-message))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/client-limit-exceeded-exception (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo.client-limit-exceeded-exception/Message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/continuation-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__15966__auto__] (clojure.core/<= 1 (clojure.core/count s__15966__auto__))) (clojure.core/fn [s__15967__auto__] (clojure.core/< (clojure.core/count s__15967__auto__) 128)) (clojure.core/fn [s__15968__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\.\-]+$" s__15968__auto__))))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.invalid-argument-exception/message (clojure.spec.alpha/and :portkey.aws.kinesisvideo/error-message))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/invalid-argument-exception (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo.invalid-argument-exception/Message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.kinesisvideo.connection-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.kinesisvideo/error-message))
(clojure.spec.alpha/def :portkey.aws.kinesisvideo/connection-limit-exceeded-exception (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo.connection-limit-exceeded-exception/Message] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/resourcearn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__15966__auto__] (clojure.core/<= 1 (clojure.core/count s__15966__auto__))) (clojure.core/fn [s__15967__auto__] (clojure.core/< (clojure.core/count s__15967__auto__) 1024)) (clojure.core/fn [s__15968__auto__] (clojure.core/re-matches #"arn:aws:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+" s__15968__auto__))))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/get-media-output (portkey.aws/json-keys :req-un [] :opt-un [:portkey.aws.kinesisvideo/ContentType :portkey.aws.kinesisvideo/Payload] :locations {}))

(clojure.spec.alpha/def :portkey.aws.kinesisvideo/fragment-timecode-type (clojure.spec.alpha/conformer (clojure.core/let [m__15964__auto__ {"ABSOLUTE" "ABSOLUTE", :absolute "ABSOLUTE", "RELATIVE" "RELATIVE", :relative "RELATIVE"}] (clojure.core/fn [s__15965__auto__] (m__15964__auto__ s__15965__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.aws/dashed)))

(clojure.core/defn get-media "<p> Use this API to retrieve media content from a Kinesis video stream. In the request, you identify stream name or stream Amazon Resource Name (ARN), and the starting chunk. Kinesis Video Streams then returns a stream of chunks in order by fragment number.</p> <note> <p> You must first call the <code>GetDataEndpoint</code> API to get an endpoint to which you can then send the <code>GetMedia</code> requests. </p> </note> <p>When you put media data (fragments) on a stream, Kinesis Video Streams stores each incoming fragment and related metadata in what is called a \"chunk.\" For more information, see . The <code>GetMedia</code> API returns a stream of these chunks starting from the chunk that you specify in the request. </p> <p>The following limits apply when using the <code>GetMedia</code> API:</p> <ul> <li> <p>A client can call <code>GetMedia</code> up to five times per second per stream. </p> </li> <li> <p>Kinesis Video Streams sends media data at a rate of up to 25 megabytes per second (or 200 megabits per second) during a <code>GetMedia</code> session. </p> </li> </ul>" ([get-media-input] (portkey.aws/-rest-json-call portkey.aws.kinesisvideo/endpoints "POST" "/getMedia" get-media-input :portkey.aws.kinesisvideo/get-media-input {:payload nil, :move {}, :headers {}, :uri {}, :querystring {}} nil :portkey.aws.kinesisvideo/get-media-output {"ResourceNotFoundException" :portkey.aws.kinesisvideo/resource-not-found-exception, "NotAuthorizedException" :portkey.aws.kinesisvideo/not-authorized-exception, "InvalidEndpointException" :portkey.aws.kinesisvideo/invalid-endpoint-exception, "ClientLimitExceededException" :portkey.aws.kinesisvideo/client-limit-exceeded-exception, "ConnectionLimitExceededException" :portkey.aws.kinesisvideo/connection-limit-exceeded-exception, "InvalidArgumentException" :portkey.aws.kinesisvideo/invalid-argument-exception})))
(clojure.spec.alpha/fdef get-media :args (clojure.spec.alpha/tuple :portkey.aws.kinesisvideo/get-media-input) :ret (clojure.spec.alpha/and :portkey.aws.kinesisvideo/get-media-output))

(clojure.core/defn put-media "<p> Use this API to send media data to a Kinesis video stream. </p> <note> <p> Before using this API, you must call the <code>GetDataEndpoint</code> API to get an endpoint. You then specify the endpoint in your <code>PutMedia</code> request. </p> </note> <p> In the request, you use the HTTP headers to provide parameter information, for example, stream name, time stamp, and whether the time stamp value is absolute or relative to when the producer started recording. You use the request body to send the media data. Kinesis Video Streams supports only the Matroska (MKV) container format for sending media data using this API. </p> <p>You have the following options for sending data using this API:</p> <ul> <li> <p>Send media data in real time: For example, a security camera can send frames in real time as it generates them. This approach minimizes the latency between the video recording and data sent on the wire. This is referred to as a continuous producer. In this case, a consumer application can read the stream in real time or when needed. </p> </li> <li> <p>Send media data offline (in batches): For example, a body camera might record video for hours and store it on the device. Later, when you connect the camera to the docking port, the camera can start a <code>PutMedia</code> session to send data to a Kinesis video stream. In this scenario, latency is not an issue. </p> </li> </ul> <p>When using this API, note the following considerations:</p> <ul> <li> <p>You must specify either <code>streamName</code> or <code>streamARN</code>, but not both.</p> </li> <li> <p> You might find it easier to use a single long-running <code>PutMedia</code> session and send a large number of media data fragments in the payload. Note that for each fragment received, Kinesis Video Streams sends one or more acknowledgements. Potential network considerations might cause you to not get all these acknowledgements as they are generated. </p> </li> <li> <p> You might choose multiple consecutive <code>PutMedia</code> sessions, each with fewer fragments to ensure that you get all acknowledgements from the service in real time. </p> </li> </ul> <note> <p>If you send data to the same stream on multiple simultaneous <code>PutMedia</code> sessions, the media fragments get interleaved on the stream. You should make sure that this is OK in your application scenario. </p> </note> <p>The following limits apply when using the <code>PutMedia</code> API:</p> <ul> <li> <p>A client can call <code>PutMedia</code> up to five times per second per stream.</p> </li> <li> <p>A client can send up to five fragments per second per stream.</p> </li> <li> <p>Kinesis Video Streams reads media data at a rate of up to 12.5 MB/second, or 100 Mbps during a <code>PutMedia</code> session. </p> </li> </ul> <p>Note the following constraints. In these cases, Kinesis Video Streams sends the Error acknowledgement in the response. </p> <ul> <li> <p>Fragments that have time codes spanning longer than 10 seconds and that contain more than 50 megabytes of data are not allowed. </p> </li> <li> <p> An MKV stream containing more than one MKV segment or containing disallowed MKV elements (like <code>track*</code>) also results in the Error acknowledgement. </p> </li> </ul> <p>Kinesis Video Streams stores each incoming fragment and related metadata in what is called a \"chunk.\" The fragment metadata includes the following: </p> <ul> <li> <p>The MKV headers provided at the start of the <code>PutMedia</code> request</p> </li> <li> <p>The following Kinesis Video Streams-specific metadata for the fragment:</p> <ul> <li> <p> <code>server_timestamp</code> - Time stamp when Kinesis Video Streams started receiving the fragment. </p> </li> <li> <p> <code>producer_timestamp</code> - Time stamp, when the producer started recording the fragment. Kinesis Video Streams uses three pieces of information received in the request to calculate this value. </p> <ul> <li> <p>The fragment timecode value received in the request body along with the fragment.</p> </li> <li> <p>Two request headers: <code>producerStartTimestamp</code> (when the producer started recording) and <code>fragmentTimeCodeType</code> (whether the fragment timecode in the payload is absolute or relative).</p> </li> </ul> <p>Kinesis Video Streams then computes the <code>producer_timestamp</code> for the fragment as follows:</p> <p> If <code>fragmentTimeCodeType</code> is relative, then </p> <p> <code>producer_timestamp</code> = <code>producerStartTimeSamp</code> + fragment timecode </p> <p>If <code>fragmentTimeCodeType</code> is absolute, then </p> <p> <code>producer_timestamp</code> = fragment timecode (converted to milliseconds)</p> </li> <li> <p>Unique fragment number assigned by Kinesis Video Streams.</p> </li> </ul> <p/> </li> </ul> <note> <p> When you make the <code>GetMedia</code> request, Kinesis Video Streams returns a stream of these chunks. The client can process the metadata as needed. </p> </note> <note> <p>This operation is only available for the AWS SDK for Java. It is not supported in AWS SDKs for other languages.</p> </note>" ([put-media-input] (portkey.aws/-rest-json-call portkey.aws.kinesisvideo/endpoints "POST" "/putMedia" put-media-input :portkey.aws.kinesisvideo/put-media-input {:payload "Payload", :move {}, :headers {"StreamName" ["x-amzn-stream-name" nil], "StreamARN" ["x-amzn-stream-arn" nil], "FragmentTimecodeType" ["x-amzn-fragment-timecode-type" nil], "ProducerStartTimestamp" ["x-amzn-producer-start-timestamp" nil]}, :uri {}, :querystring {}} nil :portkey.aws.kinesisvideo/put-media-output {"ResourceNotFoundException" :portkey.aws.kinesisvideo/resource-not-found-exception, "NotAuthorizedException" :portkey.aws.kinesisvideo/not-authorized-exception, "InvalidEndpointException" :portkey.aws.kinesisvideo/invalid-endpoint-exception, "InvalidArgumentException" :portkey.aws.kinesisvideo/invalid-argument-exception, "ClientLimitExceededException" :portkey.aws.kinesisvideo/client-limit-exceeded-exception, "ConnectionLimitExceededException" :portkey.aws.kinesisvideo/connection-limit-exceeded-exception})))
(clojure.spec.alpha/fdef put-media :args (clojure.spec.alpha/tuple :portkey.aws.kinesisvideo/put-media-input) :ret (clojure.spec.alpha/and :portkey.aws.kinesisvideo/put-media-output))
